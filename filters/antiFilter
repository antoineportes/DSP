/*
  I've created this filter as a part of a "fractional order" filter [project].
  It's the inverse of a 1-pole low-pass filter:
  H(s) = 1 / (s + 1)  -->  H(s) = s + 1

  Its initial purpose was to cancel an instance of RC circuit in the analog model and never actually be heard, but it turns out that it makes a quite interesting high-shelf.
  (In such use cases, ultrasonic filtering is strongly advised so that clippers and meters don't go crazy).

  Notice:
  Hz is the cutoff frequency (in Hertz).
  sRate is the sampling frequency (in Hertz i.e. samples per second).
  Ts = 1 / sRate is the sampling period.

  "Low-pass" actually means "Anti-Low-pass"
  "High-pass" actually means "Anti-High-pass"
*/


################################################################
LOW-PASS
################################################################


//  Transfer function:

  H(s) = s + 1

  s --> s / wc    :    H(s) = (s + wc) / wc

  wc = 2 / Ts * aTan(2 * pi * Hz * Ts / 2)    (prewarping at cutoff)


//  Bilinear transform (BLT):

          2 * (z - 1)
  s --> --------------    (inverse trapezoidal integrator)
         Ts * (z + 1)

            2 * z - 2 + Ts * wc * z + Ts * wc                                                  /        2    \              /        2    \
           -----------------------------------                                                〈 1 - ---------- ⟩ * z^-1  +  〈 1 + ---------- ⟩
                       Ts * z + Ts                    (Ts * wc + 2) * z + (Ts * wc - 2)        \     Ts * wc /              \     Ts * wc /
  H(z) = ---------------------------------------  =  -----------------------------------  =  -------------------------------------------------
                          wc                              (Ts * wc) * z + (Ts * wc)                               z^-1  +  1


//  Intermediate variable:

            2                            2                                      1
  tmp = ---------  =  -----------------------------------------  =  -----------------------     //  could use PI_SRATE = pi / sRate as a constant and just multiply it by Hz...
         Ts * wc             2          /               Ts \               /        Hz  \       //  could create tmp.cutoff = aTan(PI_SRATE * Hz) to compute it only once per cascade
                       Ts * ---- * aTan〈 2 * pi * Hz * ----- ⟩         aTan〈 pi * -------- ⟩     //  or maybe g = aTan(PI_SRATE * Hz) ; _g = 1 / g; *
                             Ts         \                2 /               \      sRate  /      //  * In a function, g and _g could be local variables (?).

//  Coefficients:

  b0 = 1 + tmp
  b1 = 1 - tmp
  a0 = a1 = 1    =>  (-a1 = -1)


//  Transposed direct form II:
////  Block diagram:

  x[n] -->o-->[ * b0 ]-->(+)------------->o--> y[n]
          |               ^               |
          |               |               |
          |            [ z^-1 ]           |
          |               ^               |
          |               |               |
          |-->[ * b1 ]-->(+)<--[ * -a1 ]<-|

////  Algorithm:

  y  = b0 * x + z1;
  z1 = b1 * x - y;


//  Bode plot ("analog" model, magnitude only):

  https://www.desmos.com/calculator/4wo4pqiz8p



################################################################
HIGH-PASS
################################################################


//  Transfer function:

  H(s) = (s + 1) / s

  s --> s / wc    :    H(s) = (s + wc) / s

  wc = 2 / Ts * aTan(2 * pi * Hz * Ts / 2)    (prewarping at cutoff)


//  Bilinear transform (BLT):

          2 * (z - 1)
  s --> --------------    (inverse trapezoidal integrator)
         Ts * (z + 1)

            2 * z - 2  +  Ts * wc * z  +  Ts * wc                                                    / Ts * wc    \       / Ts * wc    \
           ---------------------------------------                                                  〈 --------- + 1 ⟩  +  〈 --------- - 1 ⟩ * z^-1
                         Ts * z + Ts                      (Ts * wc + 2) * z  +  (Ts * wc - 2)        \    2       /       \    2       /
  H(z)  =  -----------------------------------------  =  -------------------------------------  =  ----------------------------------------------
                          2 * z - 2                                   2 * z  -  2                                  1  -  z^-1
                        -------------
                         Ts * z + Ts


//  Intermediate variable:

                              2          /              Ts \
                       Ts * ----- * aTan〈2 * pi * Hz * ----- ⟩
         Ts * wc              Ts         \               2 /
  tmp = ---------  =  -----------------------------------------  =  aTan(PI_SRATE * Hz)
            2                             2

//  Coefficients:

  b0 = tmp + 1
  b1 = tmp - 1
  a0 = 1
  a1 = -1    =>  (-a1 = 1)


//  Transposed direct form II:
////  Block diagram:

  x[n] -->o-->[ * b0 ]-->(+)------------->o--> y[n]
          |               ^               |
          |               |               |
          |            [ z^-1 ]           |
          |               ^               |
          |               |               |
          |-->[ * b1 ]-->(+)<--[ * -a1 ]<-|

////  Algorithm:

  y  = b0 * x + z1;
  z1 = b1 * x + y;


//  Bode plot ("analog" model, magnitude only):

  https://www.desmos.com/calculator/hgfzihkhmq


################################################################
ALTERNATIVE IMPLEMENTATION: TPT / ZDF
################################################################

//  Inverse trapezoidal integrator
  
   y        2 * (z - 1)                              2
  ---  =  --------------    <=>    y * z + y  =  --------- * (x * z - x)
   x       Ts * (z + 1)                           wc * Ts

             2                   2
         --------- * x * z - --------- * x - y
          wc * Ts             wc * Ts                   2            /    2            \
  y  =  ---------------------------------------  =  --------- * x - 〈 ---------- * x + y ⟩ * z^-1
                          z                          wc * Ts         \ wc * Ts         /

  Hence:

  x -->[ _g ]-->o--->(+)--->o--> y      //    _g = 2 / (wc * Ts)
                |     ^ -   |
                |     |     |
                |  [ z^-1 ] |
                |     ^     |
                |     |     |
                |--->(+)<---|


//  Low-pass
////  "Analog" block diagram:

  x -->o-->[ * s ]-->(+)--> y          //    An integrator basically divides by s
       |              ^ +              //    so an inverse integrator basically multiplies by s.
       |--------------|


////  Replacing the inverse integrator with an inverse trapezoidal integrator:
                    u           v
  x -->o-->[ _g ]-->o--->(+)--->o-->(+)--> y
       |            |     ^ -   |    ^ +
       |            |     |     |    |
       |            |  [ z^-1 ] |    |
       |            |     ^     |    |
       |            |     |     |    |
       |            |--->(+)<---|    |
       |-----------------------------|


////  Alogorithm:

  _g  =  1 / aTan(PI_SRATE * Hz);
  
  u  = _g * x;        //  tmp1
  v  =  u - z1;       //  tmp2
  z1 =  u + v;
  y  =  v + x;


//  Trapezoidal integrator
  
   y        2 * (z - 1)                              2
  ---  =  --------------    <=>    y * z + y  =  --------- * (x * z - x)
   x       Ts * (z + 1)                           wc * Ts

          wc * Ts             wc * Ts
         --------- * x * z + --------- * x + y
             2                   2                   wc * Ts         / wc * Ts         \
  y  =  ---------------------------------------  =  --------- * x + 〈 ---------- * x + y ⟩ * z^-1
                          z                             2            \    2            /

  Hence:

  x -->[ g ]-->o--->(+)--->o--> y      //    g = (wc * Ts) / 2
               |     ^ +   |
               |     |     |
               |  [ z^-1 ] |
               |     ^     |
               |     |     |
               |--->(+)<---|


//  High-pass
////  "Analog" block diagram:

  x -->o-->[ / s ]-->(+)--> y
       |              ^ +
       |--------------|


////  Replacing the inverse integrator with an inverse trapezoidal integrator:
                   u           v
  x -->o-->[ g ]-->o--->(+)--->o-->(+)--> y
       |           |     ^ +   |    ^ +
       |           |     |     |    |
       |           |  [ z^-1 ] |    |
       |           |     ^     |    |
       |           |     |     |    |
       |           |--->(+)<---|    |
       |----------------------------|


////  Alogorithm:

  g  =  aTan(PI_SRATE * Hz);
  
  u  =  g * x;        //  tmp1
  v  =  u + z1;       //  tmp2
  z1 =  u + v;
  y  =  v + x;
